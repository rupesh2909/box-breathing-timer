<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Timer — Wake Lock + PiP (Persistent Status)</title>
<style>
  *{box-sizing:border-box}
  body{
    margin:0;min-height:100vh;display:flex;align-items:center;
    justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:linear-gradient(135deg,#0f172a,#0ea5e9);color:#fff;padding:18px;
  }
  .card{width:100%;max-width:620px;background:rgba(255,255,255,0.06);
    border-radius:14px;padding:18px;text-align:center;box-shadow:0 12px 48px rgba(0,0,0,0.35);}
  h1{margin:0 0 8px 0;font-size:1.12rem}
  .display{font-size:3.6rem;margin:12px 0;font-weight:600;letter-spacing:2px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin:12px 0}
  .control-block{min-width:120px}
  input[type=number]{padding:8px;border-radius:8px;border:none;min-width:110px;text-align:center}
  label.small{font-size:0.85rem;display:block;margin-bottom:6px;opacity:.95}
  button{padding:10px 14px;border-radius:8px;border:none;cursor:pointer;font-size:1rem}
  .btn-start{background:#10b981;color:#fff}
  .btn-pause{background:#f59e0b;color:#fff}
  .btn-reset{background:#ef4444;color:#fff}
  .btn-save{background:#3b82f6;color:#fff}
  .btn-clear{background:#6b7280;color:#fff}
  .btn-pip{background:#7c3aed;color:#fff}
  .btn-wake{background:#06b6d4;color:#071b2a;color:#fff}
  .hint{font-size:0.85rem;opacity:0.9;margin-top:8px}
  @media (max-width:480px){.display{font-size:2.6rem}input[type=number]{min-width:92px}button{flex:1 1 45%}}
  /* hidden helpers kept attached (not display:none) */
  video#_wakelock_fallback, video#_pip_video{position:fixed;right:6px;bottom:6px;width:160px;height:90px;opacity:0.02;z-index:0}
  canvas#_pip_canvas{display:none}

  /* Persistent status bar pinned to bottom */
  .status-bar {
    position: fixed;
    left: 12px;
    right: 12px;
    bottom: 12px;
    background: rgba(2,6,23,0.9);
    color: #e6f0ff;
    border-radius: 10px;
    padding: 10px 14px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.5);
    font-size: 0.95rem;
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 9999;
  }
  .status-text { flex: 1; word-break: break-word; }
  .status-actions button {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.12);
    color: #fff;
    padding: 6px 8px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
  }
  .status-actions button:hover { background: rgba(255,255,255,0.04); }
</style>
</head>
<body>
  <div class="card" role="application" aria-label="Timer">
    <h1>Timer (MM:SS) — Wake Lock & PiP (Persistent Status)</h1>
    <div id="display" class="display" aria-live="polite">00:00</div>

    <div class="controls" aria-hidden="false">
      <div class="control-block">
        <label class="small" for="setMinutes">Initial minutes</label>
        <input id="setMinutes" type="number" min="0" step="1" placeholder="Minutes (e.g., 5)">
      </div>

      <div class="control-block">
        <label class="small" for="beepSeconds">Beep seconds (0 = off)</label>
        <input id="beepSeconds" type="number" min="0" max="59" step="1" placeholder="e.g., 3">
      </div>

      <div class="control-block">
        <label class="small" for="volume">Volume (0–100)</label>
        <input id="volume" type="number" min="0" max="100" step="1" value="80" style="width:110px;text-align:center">
      </div>
    </div>

    <div class="controls">
      <button id="setBtn" class="btn-save">Set</button>
      <button id="startBtn" class="btn-start">Start</button>
      <button id="pauseBtn" class="btn-pause">Pause</button>
      <button id="resetBtn" class="btn-reset">Reset</button>
    </div>

    <div class="controls" style="margin-top:8px">
      <button id="saveBtn" class="btn-save">Save Settings</button>
      <button id="clearBtn" class="btn-clear">Clear Saved</button>
      <button id="wakeBtn" class="btn-wake">Enable Wake Lock</button>
      <button id="pipBtn" class="btn-pip">Enable PiP</button>
    </div>

    <div class="controls" style="margin-top:6px">
      <button id="diagBtn" class="btn-clear">Run Diagnostics</button>
    </div>

    <div class="hint">
      Notes: Wake Lock & PiP require HTTPS (or localhost) and a user tap to enable. If PiP doesn't show, check Android Settings → Apps → Chrome → Picture-in-picture allowed.
    </div>
  </div>

  <!-- Hidden helper elements (attached but visually tiny) -->
  <canvas id="_pip_canvas" width="320" height="180"></canvas>
  <video id="_pip_video" playsinline muted></video>
  <video id="_wakelock_fallback" playsinline muted loop></video>

  <!-- Persistent status bar -->
  <div class="status-bar" role="status" aria-live="polite">
    <div class="status-text" id="statusText">Ready</div>
    <div class="status-actions">
      <button id="clearStatusBtn" title="Clear status">Clear</button>
      <button id="copyStatusBtn" title="Copy status">Copy</button>
    </div>
  </div>

<script>
/* ---------------------------
   State & DOM
   --------------------------- */
const display = document.getElementById('display');
const setMinutesInput = document.getElementById('setMinutes');
const beepSecondsInput = document.getElementById('beepSeconds');
const volumeInput = document.getElementById('volume');

const setBtn = document.getElementById('setBtn');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

const saveBtn = document.getElementById('saveBtn');
const clearBtn = document.getElementById('clearBtn');
const wakeBtn = document.getElementById('wakeBtn');
const pipBtn = document.getElementById('pipBtn');
const diagBtn = document.getElementById('diagBtn');

const statusText = document.getElementById('statusText');
const clearStatusBtn = document.getElementById('clearStatusBtn');
const copyStatusBtn = document.getElementById('copyStatusBtn');

const pipCanvas = document.getElementById('_pip_canvas');
const pipCanvasCtx = pipCanvas.getContext('2d');
const pipVideo = document.getElementById('_pip_video');
const wakelockFallbackVideo = document.getElementById('_wakelock_fallback');

const STORAGE_KEY = 'timer_wakelock_pip_v2_persistentStatus';

/* ---------------------------
   Timer state
   --------------------------- */
let totalSeconds = 0;
let timerId = null;
let isRunning = false;
let audioCtx = null;

/* ---------------------------
   Audio: long beep (~2s)
   --------------------------- */
function ensureAudioContext(){
  if(!audioCtx){
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    catch(e){ audioCtx = null; console.warn('AudioContext unsupported', e); }
  }
  return audioCtx;
}
function playBeep(duration = 2000, frequency = 440){
  const ctx = ensureAudioContext(); if(!ctx) return;
  const vol = Math.max(0, Math.min(100, parseInt(volumeInput.value || 80)));
  const gain = ctx.createGain(); gain.gain.value = Math.max(0.0001, vol/150); gain.connect(ctx.destination);
  const osc = ctx.createOscillator(); osc.type='sine'; osc.frequency.value = frequency; osc.connect(gain);
  const start = ctx.currentTime; osc.start(start);
  const stopTime = start + (duration/1000);
  gain.gain.setValueAtTime(gain.gain.value, start);
  gain.gain.linearRampToValueAtTime(0.0001, stopTime);
  osc.stop(stopTime + 0.02);
}

/* ---------------------------
   Display / Timer functions
   --------------------------- */
function updateDisplay(){
  const m = Math.floor(totalSeconds / 60);
  const s = totalSeconds % 60;
  display.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}
function tick(){
  if(totalSeconds <= 0){
    clearInterval(timerId); timerId = null; isRunning = false; updateDisplay();
    playBeep(2500, 520);
    setTimeout(()=> alert("⏰ Time's up!"), 250);
    releaseWakeLock();
    setStatus('Timer finished');
    return;
  }
  totalSeconds -= 1; updateDisplay();
  // beep when seconds within minute equals configured beepSeconds
  const beepSec = Number(beepSecondsInput.value) || 0;
  if(beepSec > 0){
    const secInMin = totalSeconds % 60;
    if(secInMin === beepSec) {
      playBeep(2000, 440);
      setStatus(`Beep at ${String(secInMin).padStart(2,'0')}s in minute`);
    }
  }
  renderPipCanvas();
}

/* ---------------------------
   Controls
   --------------------------- */
function startTimer(){
  ensureAudioContext();
  attemptPlayWakeFallback(); // user gesture
  if(isRunning) return;
  if(totalSeconds <= 0){ alert('Set initial minutes > 0'); return; }
  isRunning = true;
  requestWakeLockIfAvailable();
  timerId = setInterval(tick, 1000);
  setStatus('Timer started');
  tryAutoEnterPip();
}
function pauseTimer(){ if(timerId){ clearInterval(timerId); timerId = null } isRunning = false; setStatus('Timer paused'); releaseWakeLock(); }
function resetTimer(){ pauseTimer(); totalSeconds = 0; updateDisplay(); setStatus('Timer reset'); }
function setInitialTime(){ const mins = parseInt(setMinutesInput.value); if(isNaN(mins) || mins < 0){ alert('Enter valid minutes >= 0'); return; } totalSeconds = Math.max(0, Math.floor(mins) * 60); updateDisplay(); setStatus(`Set ${mins} minute(s)`); }

/* ---------------------------
   Save / Load settings
   --------------------------- */
function saveSettings(){
  const mins = parseInt(setMinutesInput.value) || 0;
  const beep = parseInt(beepSecondsInput.value) || 0;
  const vol = parseInt(volumeInput.value) || 80;
  const payload = { minutes: mins, beepSeconds: beep, volume: vol, savedAt: new Date().toISOString() };
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); setStatus('Settings saved'); } catch(e){ console.error(e); setStatus('Could not save settings'); }
}
function clearSaved(){ localStorage.removeItem(STORAGE_KEY); setStatus('Saved settings cleared'); setMinutesInput.value=''; beepSecondsInput.value=''; volumeInput.value=80; if(!isRunning){ totalSeconds=0; updateDisplay(); } }
function loadSettings(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY); if(!raw){ setStatus('No saved settings'); return; }
    const cfg = JSON.parse(raw);
    if(typeof cfg.minutes === 'number') setMinutesInput.value = cfg.minutes;
    if(typeof cfg.beepSeconds === 'number') beepSecondsInput.value = cfg.beepSeconds;
    if(typeof cfg.volume === 'number') volumeInput.value = cfg.volume;
    totalSeconds = Math.max(0, Math.floor(cfg.minutes) * 60);
    updateDisplay();
    setStatus(`Loaded saved settings (saved at ${new Date(cfg.savedAt).toLocaleString()})`);
  } catch(e) { console.error(e); setStatus('Error loading saved settings'); }
}

/* ---------------------------
   Persistent Status functions
   --------------------------- */
// Persistent: status does NOT auto-clear now. It remains visible until user clears or it's overwritten.
function setStatus(msg){
  const ts = new Date().toLocaleTimeString();
  statusText.textContent = `${ts} — ${msg}`;
  // store last status so it persists across reloads if desired
  try { localStorage.setItem(STORAGE_KEY + '_lastStatus', JSON.stringify({ text: statusText.textContent, at: new Date().toISOString() })); } catch(e){}
}
function clearStatus(){
  statusText.textContent = 'Ready';
  try { localStorage.removeItem(STORAGE_KEY + '_lastStatus'); } catch(e){}
}
function copyStatusToClipboard(){
  const text = statusText.textContent || '';
  if(!navigator.clipboard) {
    // fallback
    const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select();
    try { document.execCommand('copy'); alert('Status copied'); } catch(e){ alert('Copy failed'); }
    ta.remove();
    return;
  }
  navigator.clipboard.writeText(text).then(()=> alert('Status copied'), ()=> alert('Copy failed') );
}

/* ---------------------------
   Wake Lock handling (defensive)
   --------------------------- */
let wakeLock = null;
let fallbackStreamForWake = null;

function createFallbackStreamForWake(){
  if(fallbackStreamForWake) return;
  const c = document.createElement('canvas'); c.width = 1; c.height = 1;
  const ctx = c.getContext('2d'); ctx.fillStyle='black'; ctx.fillRect(0,0,1,1);
  try {
    fallbackStreamForWake = c.captureStream ? c.captureStream(1) : null;
    if(fallbackStreamForWake){
      wakelockFallbackVideo.srcObject = fallbackStreamForWake;
      wakelockFallbackVideo.muted = true; wakelockFallbackVideo.playsInline = true; wakelockFallbackVideo.loop = true;
    }
  } catch(e){ console.warn('fallback captureStream not supported', e); fallbackStreamForWake = null; }
}

async function attemptPlayWakeFallback(){
  createFallbackStreamForWake();
  if(!wakelockFallbackVideo) return;
  try { await wakelockFallbackVideo.play().catch(e=>{}); } catch(e){ console.warn('fallback play error', e); }
}

async function requestWakeLockIfAvailable(){
  if('wakeLock' in navigator && typeof navigator.wakeLock.request === 'function'){
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      setStatus('Wake lock acquired');
      wakeLock.addEventListener('release', () => { setStatus('Wake lock released'); wakeLock = null; });
      document.addEventListener('visibilitychange', handleVisibilityChange);
    } catch(err){
      console.warn('Wake Lock request failed:', err);
      setStatus('Wake lock unavailable — using fallback');
      attemptPlayWakeFallback();
    }
  } else {
    setStatus('Wake Lock API not supported — using fallback');
    attemptPlayWakeFallback();
  }
}

async function handleVisibilityChange(){
  if(document.visibilityState === 'visible' && isRunning){
    if(!wakeLock && 'wakeLock' in navigator && typeof navigator.wakeLock.request === 'function'){
      try { wakeLock = await navigator.wakeLock.request('screen'); setStatus('Wake lock re-acquired'); }
      catch(e){ console.warn('Could not re-acquire wake lock', e); }
    } else {
      attemptPlayWakeFallback();
    }
  }
}

async function releaseWakeLock(){
  try {
    if(wakeLock && typeof wakeLock.release === 'function'){ await wakeLock.release(); wakeLock = null; setStatus('Wake lock released'); }
  } catch(e){ console.warn('Error releasing wake lock', e); }
  try {
    if(wakelockFallbackVideo && !wakelockFallbackVideo.paused){ wakelockFallbackVideo.pause(); if(fallbackStreamForWake){ fallbackStreamForWake.getTracks().forEach(t => t.stop()); fallbackStreamForWake = null; } }
  } catch(e){}
  document.removeEventListener('visibilitychange', handleVisibilityChange);
}

/* ---------------------------
   Picture-in-Picture via canvas -> video
   --------------------------- */
let pipStream = null;
let pipActive = false;

function renderPipCanvas(){
  const w = pipCanvas.width = 320;
  const h = pipCanvas.height = 180;
  pipCanvasCtx.fillStyle = '#0f172a';
  pipCanvasCtx.fillRect(0,0,w,h);
  pipCanvasCtx.fillStyle = '#fff';
  pipCanvasCtx.font = '48px sans-serif';
  pipCanvasCtx.textAlign = 'center';
  pipCanvasCtx.textBaseline = 'middle';
  const m = Math.floor(totalSeconds/60);
  const s = totalSeconds % 60;
  const text = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  pipCanvasCtx.fillText(text, w/2, h/2);
  pipCanvasCtx.font = '12px sans-serif';
  pipCanvasCtx.fillStyle = '#cbd5e1';
  pipCanvasCtx.fillText('Timer', w/2, h - 16);
}

async function startPipVideoStream(){
  try {
    if(!pipStream){
      pipStream = pipCanvas.captureStream ? pipCanvas.captureStream(15) : null;
      if(!pipStream){ setStatus('captureStream not supported — PiP via canvas unavailable'); return false; }
      pipVideo.srcObject = pipStream;
      pipVideo.muted = true; pipVideo.playsInline = true;
      await pipVideo.play();
    }
    return true;
  } catch(e){
    console.warn('Error starting PiP video stream', e);
    return false;
  }
}

async function enterPictureInPicture(){
  if(!('requestPictureInPicture' in HTMLVideoElement.prototype) && !document.pictureInPictureEnabled){
    setStatus('PiP not supported by this browser');
    return;
  }
  try {
    const ok = await startPipVideoStream();
    if(!ok){ setStatus('Could not start PiP video stream'); return; }
    if(document.pictureInPictureElement){
      setStatus('Already in PiP');
      return;
    }
    if(pipVideo.requestPictureInPicture){
      await pipVideo.requestPictureInPicture();
      pipActive = true;
      setStatus('Entered Picture-in-Picture');
      pipVideo.addEventListener('leavepictureinpicture', () => { pipActive = false; setStatus('Exited PiP'); });
    } else {
      setStatus('requestPictureInPicture not available on this element');
    }
  } catch(err){
    console.warn('PiP request failed:', err);
    setStatus('PiP request failed or blocked (user gesture required or OS setting).');
  }
}

async function tryAutoEnterPip(){
  try { await enterPictureInPicture(); } catch(e){ /* ignore */ }
}

/* ---------------------------
   Diagnostics helper
   --------------------------- */
async function runDiagnostics(){
  const lines = [];
  lines.push('=== Diagnostics ===');
  lines.push(`Secure context: ${window.isSecureContext ? 'yes' : 'no (needs HTTPS or localhost)'}`);
  lines.push(`Navigator.wakeLock supported: ${!!(navigator.wakeLock && navigator.wakeLock.request)}`);
  lines.push(`document.pictureInPictureEnabled: ${!!document.pictureInPictureEnabled}`);
  lines.push(`HTMLVideoElement.requestPictureInPicture: ${!!HTMLVideoElement.prototype.requestPictureInPicture}`);
  lines.push(`UserAgent: ${navigator.userAgent}`);
  alert(lines.join('\n'));
  console.log(lines.join('\n'));

  try {
    const c = document.createElement('canvas'); c.width=160; c.height=90;
    const ctx = c.getContext('2d'); ctx.fillStyle='black'; ctx.fillRect(0,0,160,90);
    const s = c.captureStream ? c.captureStream(12) : null;
    if(!s){ alert('canvas.captureStream not supported'); return; }
    const v = document.createElement('video'); v.muted = true; v.playsInline = true; v.srcObject = s;
    v.style.position='fixed'; v.style.right='6px'; v.style.bottom='6px'; v.style.width='160px'; v.style.height='90px';
    document.body.appendChild(v);
    await v.play().catch(e => { console.warn('video.play() blocked:', e); alert('video.play() blocked (console for details)'); });
    alert('Canvas stream video appended. You can try v.requestPictureInPicture() from console.');
  } catch(e){
    console.error('Diagnostics PiP check failed', e);
    alert('Diagnostics PiP check failed (see console).');
  }
}

/* ---------------------------
   Wiring events
   --------------------------- */
setBtn.addEventListener('click', () => { setInitialTime(); });
startBtn.addEventListener('click', () => { ensureAudioContext(); attemptPlayWakeFallback(); startTimer(); });
pauseBtn.addEventListener('click', pauseTimer);
resetBtn.addEventListener('click', resetTimer);
saveBtn.addEventListener('click', saveSettings);
clearBtn.addEventListener('click', clearSaved);
wakeBtn.addEventListener('click', async () => { await requestWakeLockIfAvailable(); });
pipBtn.addEventListener('click', async () => { sessionStorage.setItem('pip_allowed','1'); await enterPictureInPicture(); });
diagBtn.addEventListener('click', runDiagnostics);

clearStatusBtn.addEventListener('click', clearStatus);
copyStatusBtn.addEventListener('click', copyStatusToClipboard);

// keyboard space toggles start/pause
document.addEventListener('keydown', (e) => {
  if(e.key === ' ' && !/input|textarea/i.test(document.activeElement.tagName)){
    e.preventDefault();
    if(isRunning) pauseTimer(); else startTimer();
  }
  if(e.key.toLowerCase() === 'r') resetTimer();
});

/* ---------------------------
   Initialization
   --------------------------- */
function init(){
  // load last saved settings and last status (if any)
  loadSettings();
  updateDisplay();
  // restore last status if present
  try {
    const last = JSON.parse(localStorage.getItem(STORAGE_KEY + '_lastStatus') || 'null');
    if(last && last.text) statusText.textContent = last.text;
    else statusText.textContent = 'Ready';
  } catch(e){ statusText.textContent = 'Ready'; }
  renderPipCanvas();
  setInterval(() => { renderPipCanvas(); }, 500);
}
window.addEventListener('load', init);

/* ---------------------------
   Expose helpers for debugging
   --------------------------- */
window._timerDebug = {
  playBeep, requestWakeLockIfAvailable, releaseWakeLock, enterPictureInPicture, startPipVideoStream, setStatus
};
</script>
</body>
</html>
