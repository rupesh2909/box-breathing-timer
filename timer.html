<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Timer</title>
<style>
  *{box-sizing:border-box}
  body{
    margin:0;min-height:100vh;display:flex;align-items:center;
    justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:linear-gradient(135deg,#0f172a,#0ea5e9);color:#fff;padding:18px;
  }
  .card{width:100%;max-width:620px;background:rgba(255,255,255,0.06);
    border-radius:14px;padding:18px;text-align:center;box-shadow:0 12px 48px rgba(0,0,0,0.35);}
  h1{margin:0 0 8px 0;font-size:1.12rem}
  .display{font-size:3.6rem;margin:12px 0;font-weight:600;letter-spacing:2px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin:12px 0}
  .control-block{min-width:120px}
  input[type=number]{padding:8px;border-radius:8px;border:none;min-width:110px;text-align:center}
  label.small{font-size:0.85rem;display:block;margin-bottom:6px;opacity:.95}
  button{padding:10px 14px;border-radius:8px;border:none;cursor:pointer;font-size:1rem}
  .btn-start{background:#10b981;color:#fff}
  .btn-pause{background:#f59e0b;color:#fff}
  .btn-reset{background:#ef4444;color:#fff}
  .btn-save{background:#3b82f6;color:#fff}
  .btn-clear{background:#6b7280;color:#fff}
  .btn-pip{background:#7c3aed;color:#fff}
  .btn-wake{background:#06b6d4;color:#071b2a;color:#fff}
  .hint{font-size:0.85rem;opacity:0.9;margin-top:8px}
  @media (max-width:480px){.display{font-size:2.6rem}input[type=number]{min-width:92px}button{flex:1 1 45%}}
  /* hidden helpers kept attached (not display:none) */
  /* keep the video small and nearly invisible but attached; some browsers require it attached and playing */
  video#_pip_video, video#_wakelock_fallback{
    position:fixed; right:6px; bottom:6px; width:160px; height:90px; opacity:0.02; z-index:0;
  }
  canvas#_pip_canvas{display:none}
</style>
</head>
<body>
  <div class="card" role="application" aria-label="Timer">
    <h1>Timer (MM:SS)</h1>
    <div id="display" class="display" aria-live="polite">00:00</div>

    <div class="controls" aria-hidden="false">
      <div class="control-block">
        <label class="small" for="setMinutes">Initial minutes</label>
        <input id="setMinutes" type="number" min="0" step="1" placeholder="Minutes (e.g., 5)">
      </div>

      <div class="control-block">
        <label class="small" for="beepSeconds">Beep seconds (0 = off)</label>
        <input id="beepSeconds" type="number" min="0" max="59" step="1" placeholder="e.g., 3">
      </div>

      <div class="control-block">
        <label class="small" for="volume">Volume (0–100)</label>
        <input id="volume" type="number" min="0" max="100" step="1" value="80" style="width:110px;text-align:center">
      </div>
    </div>

    <div class="controls">
      <button id="setBtn" class="btn-save">Set</button>
      <button id="startBtn" class="btn-start">Start</button>
      <button id="pauseBtn" class="btn-pause">Pause</button>
      <button id="resetBtn" class="btn-reset">Reset</button>
    </div>

    <div class="controls" style="margin-top:8px">
      <button id="saveBtn" class="btn-save">Save Settings</button>
      <button id="clearBtn" class="btn-clear">Clear Saved</button>
      <button id="wakeBtn" class="btn-wake">Enable Wake Lock</button>
      <button id="pipBtn" class="btn-pip">Enable PiP</button>
    </div>
  </div>

  <!-- hidden helpers kept attached and playing as needed -->
  <canvas id="_pip_canvas" width="320" height="180"></canvas>
  <video id="_pip_video" playsinline muted></video>
  <video id="_wakelock_fallback" playsinline muted loop></video>

<script>
/* ---------------------------
   State & DOM
   --------------------------- */
const display = document.getElementById('display');
const setMinutesInput = document.getElementById('setMinutes');
const beepSecondsInput = document.getElementById('beepSeconds');
const volumeInput = document.getElementById('volume');

const setBtn = document.getElementById('setBtn');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

const saveBtn = document.getElementById('saveBtn');
const clearBtn = document.getElementById('clearBtn');
const wakeBtn = document.getElementById('wakeBtn');
const pipBtn = document.getElementById('pipBtn');

const pipCanvas = document.getElementById('_pip_canvas');
const pipCanvasCtx = pipCanvas.getContext('2d');
const pipVideo = document.getElementById('_pip_video');
const wakelockFallbackVideo = document.getElementById('_wakelock_fallback');

const STORAGE_KEY = 'timer_wakelock_pip_reentry';

/* ---------------------------
   Timer state
   --------------------------- */
let totalSeconds = 0;
let timerId = null;
let isRunning = false;
let audioCtx = null;

/* ---------------------------
   Audio: long beep (~2s)
   --------------------------- */
function ensureAudioContext(){
  if(!audioCtx){
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    catch(e){ audioCtx = null; console.warn('AudioContext unsupported', e); }
  }
  return audioCtx;
}
function playBeep(duration = 2000, frequency = 440){
  const ctx = ensureAudioContext(); if(!ctx) return;
  const vol = Math.max(0, Math.min(100, parseInt(volumeInput.value || 80)));
  const gain = ctx.createGain(); gain.gain.value = Math.max(0.0001, vol/150); gain.connect(ctx.destination);
  const osc = ctx.createOscillator(); osc.type='sine'; osc.frequency.value = frequency; osc.connect(gain);
  const start = ctx.currentTime; osc.start(start);
  const stopTime = start + (duration/1000);
  gain.gain.setValueAtTime(gain.gain.value, start);
  gain.gain.linearRampToValueAtTime(0.0001, stopTime);
  osc.stop(stopTime + 0.02);
}

/* ---------------------------
   Display / Timer functions
   --------------------------- */
function updateDisplay(){
  const m = Math.floor(totalSeconds / 60);
  const s = totalSeconds % 60;
  display.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}
function tick(){
  if(totalSeconds <= 0){
    clearInterval(timerId); timerId = null; isRunning = false; updateDisplay();
    playBeep(2500, 520);
    releaseWakeLock();
    console.log('Timer finished');
    return;
  }
  totalSeconds -= 1; updateDisplay();
  const beepSec = Number(beepSecondsInput.value) || 0;
  if(beepSec > 0){
    const secInMin = totalSeconds % 60;
    if(secInMin === beepSec) {
      playBeep(2000, 440);
      console.log(`Beep at ${secInMin}s in minute`);
    }
  }
  renderPipCanvas();
}

/* ---------------------------
   Controls
   --------------------------- */
function startTimer(){
  ensureAudioContext();
  attemptPlayWakeFallback(); // user gesture
  if(isRunning) return;
  if(totalSeconds <= 0){ console.log('Set initial minutes > 0'); return; }
  isRunning = true;
  requestWakeLockIfAvailable();
  timerId = setInterval(tick, 1000);
  console.log('Timer started');
  // ensure pipVideo stream is started so PiP can be entered later
  startPipVideoStream().then(() => {
    // if user previously enabled pip, try to auto-enter (may succeed or fail depending on browser)
    if(sessionStorage.getItem('pip_allowed') === '1'){
      tryAutoEnterPip();
    }
  });
}
function pauseTimer(){ if(timerId){ clearInterval(timerId); timerId = null } isRunning = false; console.log('Timer paused'); releaseWakeLock(); }
function resetTimer(){ pauseTimer(); totalSeconds = 0; updateDisplay(); console.log('Timer reset'); }
function setInitialTime(){ const mins = parseInt(setMinutesInput.value); if(isNaN(mins) || mins < 0){ console.log('Enter valid minutes'); return; } totalSeconds = Math.max(0, Math.floor(mins) * 60); updateDisplay(); console.log(`Set ${mins} minute(s)`); }

/* ---------------------------
   Save / Load settings
   --------------------------- */
function saveSettings(){
  const mins = parseInt(setMinutesInput.value) || 0;
  const beep = parseInt(beepSecondsInput.value) || 0;
  const vol = parseInt(volumeInput.value) || 80;
  const payload = { minutes: mins, beepSeconds: beep, volume: vol, savedAt: new Date().toISOString() };
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); console.log('Settings saved'); } catch(e){ console.error(e); console.log('Could not save settings'); }
}
function clearSaved(){ localStorage.removeItem(STORAGE_KEY); console.log('Saved settings cleared'); setMinutesInput.value=''; beepSecondsInput.value=''; volumeInput.value=80; if(!isRunning){ totalSeconds=0; updateDisplay(); } }
function loadSettings(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY); if(!raw){ console.log('No saved settings'); return; }
    const cfg = JSON.parse(raw);
    if(typeof cfg.minutes === 'number') setMinutesInput.value = cfg.minutes;
    if(typeof cfg.beepSeconds === 'number') beepSecondsInput.value = cfg.beepSeconds;
    if(typeof cfg.volume === 'number') volumeInput.value = cfg.volume;
    totalSeconds = Math.max(0, Math.floor(cfg.minutes) * 60);
    updateDisplay();
    console.log(`Loaded saved settings (saved at ${new Date(cfg.savedAt).toLocaleString()})`);
  } catch(e) { console.error(e); console.log('Error loading saved settings'); }
}

/* ---------------------------
   Wake Lock handling (defensive)
   --------------------------- */
let wakeLock = null;
let fallbackStreamForWake = null;

function createFallbackStreamForWake(){
  if(fallbackStreamForWake) return;
  const c = document.createElement('canvas'); c.width = 1; c.height = 1;
  const ctx = c.getContext('2d'); ctx.fillStyle='black'; ctx.fillRect(0,0,1,1);
  try {
    fallbackStreamForWake = c.captureStream ? c.captureStream(1) : null;
    if(fallbackStreamForWake){
      wakelockFallbackVideo.srcObject = fallbackStreamForWake;
      wakelockFallbackVideo.muted = true; wakelockFallbackVideo.playsInline = true; wakelockFallbackVideo.loop = true;
    }
  } catch(e){ console.warn('fallback captureStream not supported', e); fallbackStreamForWake = null; }
}

async function attemptPlayWakeFallback(){
  createFallbackStreamForWake();
  if(!wakelockFallbackVideo) return;
  try { await wakelockFallbackVideo.play().catch(e=>{}); } catch(e){ console.warn('fallback play error', e); }
}

async function requestWakeLockIfAvailable(){
  if('wakeLock' in navigator && typeof navigator.wakeLock.request === 'function'){
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake lock acquired');
      wakeLock.addEventListener('release', () => { console.log('Wake lock released'); wakeLock = null; });
      document.addEventListener('visibilitychange', handleVisibilityChange);
    } catch(err){
      console.warn('Wake Lock request failed:', err);
      console.log('Wake lock unavailable — using fallback');
      attemptPlayWakeFallback();
    }
  } else {
    console.log('Wake Lock API not supported — using fallback');
    attemptPlayWakeFallback();
  }
}

async function handleVisibilityChange(){
  // when page becomes visible again, ensure pipVideo stream is running if timer is running
  if(document.visibilityState === 'visible'){
    if(isRunning){
      // try to re-acquire wake lock if needed
      if(!wakeLock && 'wakeLock' in navigator && typeof navigator.wakeLock.request === 'function'){
        try { wakeLock = await navigator.wakeLock.request('screen'); console.log('Wake lock re-acquired'); }
        catch(e){ console.warn('Could not re-acquire wake lock', e); }
      } else {
        attemptPlayWakeFallback();
      }

      // ensure pip stream is playing and if allowed by user, try to re-enter PiP
      await startPipVideoStream().catch(()=>{});
      if(sessionStorage.getItem('pip_allowed') === '1' && !document.pictureInPictureElement){
        // some browsers allow requestPictureInPicture without a gesture if video is playing
        try { await enterPictureInPicture(); } catch(e){ console.warn('Auto PiP re-entry blocked', e); }
      }
    } else {
      // if not running, ensure pipVideo not playing unnecessarily
      // don't forcibly stop it — keep it ready for fast re-entry
    }
  }
}

async function releaseWakeLock(){
  try {
    if(wakeLock && typeof wakeLock.release === 'function'){ await wakeLock.release(); wakeLock = null; console.log('Wake lock released'); }
  } catch(e){ console.warn('Error releasing wake lock', e); }
  try {
    if(wakelockFallbackVideo && !wakelockFallbackVideo.paused){ wakelockFallbackVideo.pause(); if(fallbackStreamForWake){ fallbackStreamForWake.getTracks().forEach(t => t.stop()); fallbackStreamForWake = null; } }
  } catch(e){}
  document.removeEventListener('visibilitychange', handleVisibilityChange);
}

/* ---------------------------
   Picture-in-Picture via canvas -> video (reliable & re-entrant)
   --------------------------- */
let pipStream = null;
let pipActive = false;

function renderPipCanvas(){
  const w = pipCanvas.width = 320;
  const h = pipCanvas.height = 180;
  pipCanvasCtx.fillStyle = '#0f172a';
  pipCanvasCtx.fillRect(0,0,w,h);
  pipCanvasCtx.fillStyle = '#fff';
  pipCanvasCtx.font = '48px sans-serif';
  pipCanvasCtx.textAlign = 'center';
  pipCanvasCtx.textBaseline = 'middle';
  const m = Math.floor(totalSeconds/60);
  const s = totalSeconds % 60;
  const text = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  pipCanvasCtx.fillText(text, w/2, h/2);
  pipCanvasCtx.font = '12px sans-serif';
  pipCanvasCtx.fillStyle = '#cbd5e1';
  pipCanvasCtx.fillText('Timer', w/2, h - 16);
}

async function startPipVideoStream(){
  try {
    if(!pipStream){
      // create captureStream of canvas; keep it ready while timer runs
      pipStream = pipCanvas.captureStream ? pipCanvas.captureStream(15) : null;
      if(!pipStream){ console.log('captureStream not supported — PiP via canvas unavailable'); return false; }
      pipVideo.srcObject = pipStream;
      pipVideo.muted = true; pipVideo.playsInline = true;
      // play the video; required in many browsers before requestPictureInPicture
      await pipVideo.play();
    } else {
      // if stream exists but video paused, try to play it
      if(pipVideo.paused) await pipVideo.play().catch(()=>{});
    }
    return true;
  } catch(e){
    console.warn('Error starting PiP video stream', e);
    return false;
  }
}

async function enterPictureInPicture(){
  if(!('requestPictureInPicture' in HTMLVideoElement.prototype) && !document.pictureInPictureEnabled){
    console.log('PiP not supported by this browser');
    return;
  }
  try {
    const ok = await startPipVideoStream();
    if(!ok){ console.log('Could not start PiP video stream'); return; }
    if(document.pictureInPictureElement){
      console.log('Already in PiP');
      return;
    }
    if(pipVideo.requestPictureInPicture){
      // request PiP — may require user gesture in some browsers; may succeed if pipVideo is playing
      await pipVideo.requestPictureInPicture();
      pipActive = true;
      console.log('Entered Picture-in-Picture');
      // when PiP is closed by user (e.g., user taps the PiP window), this event fires
      pipVideo.addEventListener('leavepictureinpicture', () => {
        pipActive = false;
        console.log('Exited PiP');
        // keep the pipVideo stream running and ready so user can re-enter quickly
        // (do NOT remove pipVideo or stop the stream)
      }, { once: false });
      pipVideo.addEventListener('enterpictureinpicture', () => {
        pipActive = true;
        console.log('PiP entered (event)');
      }, { once: false });
    } else {
      console.log('requestPictureInPicture not available on this element');
    }
  } catch(err){
    console.warn('PiP request failed:', err);
    console.log('PiP request failed or blocked (user gesture required or OS setting).');
  }
}

async function tryAutoEnterPip(){
  try { await enterPictureInPicture(); } catch(e){ /* ignore */ }
}

/* ---------------------------
   Visibility and focus handling
   --------------------------- */
// When user returns to the page (visibilitychange to visible), try to re-start pip stream and re-enter PiP if user had previously enabled it.
document.addEventListener('visibilitychange', async () => {
  if(document.visibilityState === 'visible'){
    // if timer is running, ensure pip video stream is playing
    if(isRunning){
      await startPipVideoStream().catch(()=>{});
      // If user had tapped Enable PiP earlier, try to re-enter automatically
      if(sessionStorage.getItem('pip_allowed') === '1' && !document.pictureInPictureElement){
        try { await enterPictureInPicture(); } catch(e){ console.warn('Auto PiP re-entry blocked', e); }
      }
    }
  } else {
    // page hidden — nothing to do
  }
});

// Also attempt re-entry on window focus (some browsers behave better with focus)
window.addEventListener('focus', async () => {
  if(isRunning && sessionStorage.getItem('pip_allowed') === '1' && !document.pictureInPictureElement){
    try { await startPipVideoStream().catch(()=>{}); await enterPictureInPicture(); } catch(e){ /* ignore */ }
  }
});

/* ---------------------------
   Wiring events
   --------------------------- */
setBtn.addEventListener('click', () => { setInitialTime(); });
startBtn.addEventListener('click', () => {
  ensureAudioContext();
  attemptPlayWakeFallback();
  startTimer();
});
pauseBtn.addEventListener('click', pauseTimer);
resetBtn.addEventListener('click', resetTimer);
saveBtn.addEventListener('click', saveSettings);
clearBtn.addEventListener('click', clearSaved);
wakeBtn.addEventListener('click', async () => { await requestWakeLockIfAvailable(); });
pipBtn.addEventListener('click', async () => {
  // mark that user allowed PiP in this session / tab
  sessionStorage.setItem('pip_allowed','1');
  await enterPictureInPicture();
});

// keyboard space toggles start/pause
document.addEventListener('keydown', (e) => {
  if(e.key === ' ' && !/input|textarea/i.test(document.activeElement.tagName)){
    e.preventDefault();
    if(isRunning) pauseTimer(); else startTimer();
  }
  if(e.key.toLowerCase() === 'r') resetTimer();
});

/* ---------------------------
   Initialization
   --------------------------- */
function init(){
  loadSettings();
  updateDisplay();
  renderPipCanvas();
  // keep updating pip canvas so PiP content stays fresh
  setInterval(() => { renderPipCanvas(); }, 500);
}
window.addEventListener('load', init);

/* ---------------------------
   Expose minimal debug helpers
   --------------------------- */
window._timerDebug = { playBeep, requestWakeLockIfAvailable, releaseWakeLock, enterPictureInPicture, startPipVideoStream };
</script>
</body>
</html>
